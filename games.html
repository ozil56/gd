<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>æ¼è›‹è®°åˆ†å™¨ Â· ç²¾ç®€ç‰ˆ</title>
<style>
  :root{
    --bg: #fff7ed;          /* æŸ”å’ŒèƒŒæ™¯ */
    --card: #ffffff;        /* å¡ç‰‡åº•è‰² */
    --text: #111827;        /* ä¸»æ–‡æœ¬ */
    --muted:#6b7280;        /* æ¬¡æ–‡æœ¬ */
    --brand:#dc2626;        /* å“ç‰Œçº¢ */
    --ok:#16a34a;           /* ç»¿è‰² */
    --warn:#f59e0b;         /* æ©™è‰² */
    --info:#2563eb;         /* è“è‰² */
    --shadow: 0 6px 18px rgba(17,24,39,0.08);
    --radius: 14px;
    --gap: 10px;
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background: linear-gradient(135deg,#fff5f5 0%, var(--bg) 100%);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    color: var(--text);
    overflow: hidden; /* ä¸»ç•Œé¢ä¸æ»šåŠ¨ */
  }

  /* æ•´ä½“é‡‡ç”¨å•å±ç½‘æ ¼å¸ƒå±€ï¼Œä¿è¯æ‰‹æœºä¸€å±å±•ç¤º */
  .container{
    height: 100vh;
    max-width: 420px;
    margin: 0 auto;
    padding: 10px;
    display: grid;
    grid-template-rows: auto auto 1fr auto;
    gap: var(--gap);
  }

  .topbar{
    background: var(--card);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 10px 12px;
    display:flex; align-items:flex-start; gap:12px;
    flex-wrap:wrap;
  }
  .title{display:flex; align-items:center; gap:8px; font-weight:800; color:var(--brand)}
  .title .emoji{font-size:20px}
  .session-info{
    display:flex;
    flex-direction:column;
    gap:2px;
    font-size:12px;
    color:var(--muted);
    min-width:160px;
  }
  .session-info .game-id{font-weight:600; color:var(--text);}
  .session-info .status{padding:0; box-shadow:none; background:transparent;}
  .session-info .status[data-tone="error"]{color:var(--brand);}
  .session-info .status[data-tone="warn"]{color:var(--warn);}
  .session-info .status[data-tone="ok"]{color:var(--ok);}
  .session-info .status[data-tone="sync"]{color:var(--info);}
  .top-actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
  .btn{
    border:0; border-radius:10px; padding:8px 10px; font-weight:700; cursor:pointer;
    background:#f3f4f6; color:#111827;
  }
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btn.primary{background: var(--info); color:white}
  .btn.danger{background:#ef4444; color:white}
  .btn.ghost{background:#f3f4f6}
  .btn.warn{background: var(--warn); color:#111827}

  /* ç‰Œé¢åŒºï¼šä¸¤è¡Œï¼Œæ¯è¡Œä¸€é˜Ÿï¼šå·¦ç‰Œå³æŒ‰é’® */
  .board{
    background: var(--card);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 10px;
    display: grid;
    grid-template-rows: 1fr 1fr;
    gap: 8px;
  }

  .row{
    display:grid;
    grid-template-columns: minmax(0, 80%) minmax(0, 20%);
    gap: 10px;
    align-items: center;
  }

  .card{
    position:relative;
    background: white;
    border: 3px solid #e5e7eb;
    border-radius: 14px;
    padding: 10px;
    display:flex; align-items:center; justify-content:space-between;
    min-height: 84px;
  }
  .card.a{border-color:#dbeafe} /* Aé˜Ÿè“è¾¹ */
  .card.b{border-color:#fee2e2} /* Bé˜Ÿçº¢è¾¹ */

  .left{
    display:flex; align-items:center; gap:8px;
  }
  .badge{
    font-size:12px; font-weight:800; padding:2px 6px; border-radius:999px; background:#f3f4f6; color:#374151;
  }
  .badge.team-name-btn{
    border:none;
    background:#f3f4f6;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    padding:6px 5px;
    min-width:60px;
    line-height:1.2;
    white-space:nowrap;
  }
  .badge.team-name-btn:focus{
    outline:2px solid rgba(37,99,235,0.4);
    outline-offset:1px;
  }
  .badge.team-name-btn:hover{
    background:#e2e8f0;
  }
  .badge.team-name-btn:disabled{
    cursor:not-allowed;
    opacity:0.6;
  }
  .dealer{background: #fde68a; color:#92400e;}
  .level{
    font-size:28px; font-weight:900; line-height:1;
  }
  .suit{font-size:18px; opacity:.8}
  .meta{
    display:flex; flex-direction:column; gap:2px; font-size:12px; color:var(--muted);
  }
  .meta .fails{font-weight:700; color:#ef4444}

  .crown{
    position:absolute; top:-12px; left:50%; transform:translateX(-50%);
    font-size:20px; display:none;
  }
  .card.dealing .crown{display:block}

  /* å³ä¾§æŒ‰é’®æ ˆ */
  .btns{
    display:grid; gap:8px;
  }
  .winbtn{
    width:100%; padding:12px 5px; border:0; border-radius:12px; font-weight:900; cursor:pointer;
    background:#111827; color:white; box-shadow: var(--shadow);
  }
  .winbtn.green{background: var(--ok)}
  .winbtn.orange{background: var(--warn)}
  .winbtn.red{background: #ef4444}
  .winbtn:disabled{opacity:.5; cursor:not-allowed}

  /* åº•éƒ¨å·¥å…·æ¡ï¼ˆæ’¤å› + çŠ¶æ€ï¼‰ */
  .toolbar{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
  }
  .undo{
    flex: 1;
    background: #111827; color:white; font-weight:900; padding:12px; border-radius:12px; border:0; box-shadow:var(--shadow);
  }
  .status{
    background: var(--card); border-radius:12px; padding:8px 10px; box-shadow:var(--shadow);
    font-size:12px; color:var(--muted);
  }

  /* è·èƒœæ¨ªå¹…ï¼ˆç»ˆå±€ï¼‰ */
  .winner{
    position: fixed; inset: 0; background: rgba(0,0,0,.55);
    display:none; align-items:center; justify-content:center; padding: 16px;
  }
  .winner .sheet{
    width: 100%; max-width: 420px; background:linear-gradient(135deg, #fbbf24 0%, #f97316 100%);
    border-radius: 16px; color:white; text-align:center; padding: 24px; box-shadow:var(--shadow);
  }
  .winner h2{margin:0 0 6px 0; font-size:28px}
  .winner p{margin:0 0 14px 0}
  .winner .close{background:white; color:#111827; border:0; border-radius:10px; padding:10px 14px; font-weight:800}

  /* å†å²è®°å½•å¼¹å±‚ï¼ˆä¸å ä¸»å±é«˜åº¦ï¼‰ */
  .overlay{position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:flex-end}
  .overlay .panel{
    width:100%; max-width:420px; margin:0 auto; background:var(--card); border-radius:16px 16px 0 0;
    padding:12px; box-shadow:var(--shadow); max-height:70vh; overflow:auto;
  }
  .overlay header{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .history-list{list-style:none; margin:0; padding:0; display:grid; gap:8px}
  .history-item{
    background:#f9fafb; border-radius:12px; padding:10px; display:flex; justify-content:space-between; align-items:center;
  }
  .tag{font-size:12px; padding:2px 6px; border-radius:999px; background:#eef2ff; color:#3730a3; margin-left:6px}
  .note{font-size:12px; color:#6b7280}

  /* é˜Ÿåç¼–è¾‘å¼¹å±‚ */
  .modal-overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.55); display:none;
    align-items:center; justify-content:center; padding:16px;
  }
  .modal-card{
    width:100%; max-width:360px; margin:0 auto; background:var(--card);
    border-radius:16px; padding:18px; box-shadow:var(--shadow);
    display:flex; flex-direction:column; gap:14px;
  }
  .modal-card h3{margin:0; font-size:18px;}
  .modal-card input{
    width:100%; border:2px solid #e5e7eb; border-radius:10px;
    padding:10px; font-size:16px; font-weight:600;
  }
  .modal-card input:focus{
    outline:none; border-color:#2563eb; box-shadow:0 0 0 3px rgba(37,99,235,0.15);
  }
  .modal-actions{display:flex; gap:10px; justify-content:flex-end;}
  .modal-actions .btn{flex:1;}

  /* è¾…åŠ©ï¼šå°å±è¿›ä¸€æ­¥å‹ç¼© */
  @media (max-width:360px){
    .level{font-size:24px}
    .winbtn{padding:10px}
    .undo{padding:10px}
  }
</style>
</head>
<body>
  <div class="container">
    <!-- é¡¶éƒ¨æ  -->
    <div class="topbar">
	  <div class="title"><a href="index.html" class="title" style="text-decoration:none;"><span class="emoji">ğŸ´</span>æ¼è›‹è®°åˆ†å™¨</a></div>
	  
      <div class="session-info">
        <div class="game-id">ç‰Œå±€IDï¼š<span id="gameIdDisplay">åŠ è½½ä¸­â€¦</span></div>
        <div class="status" id="syncStatus" data-tone="sync">åŒæ­¥ä¸­â€¦</div>
      </div>
      <div class="top-actions">
        <button class="btn ghost" id="btnCopyLink">å¤åˆ¶é“¾æ¥</button>
        <button class="btn warn" id="btnNewGame">æ–°ç‰Œå±€</button>
        <button class="btn ghost" id="btnHistory">å†å²</button>
        <button class="btn danger" id="btnReset">é‡ç½®</button>
      </div>
    </div>

    <!-- ç‰Œé¢ + æ“ä½œ -->
    <div class="board" id="board">
      <!-- Aé˜Ÿ -->
      <div class="row">
        <div class="card a" id="cardA">
          <div class="crown">ğŸ‘‘</div>
          <div class="left">
            <div class="level" id="lvA">2</div>
            <div class="suit">â™¥</div>
          </div>
          <div class="meta">
            <span id="infoA">è·Aè¿˜å·® 12 çº§</span>
            <span class="fails" id="failA">A1å¤±è´¥ï¼š0/3</span>
          </div>
          <button type="button" class="badge team-name-btn" id="teamNameA" data-team="A">Aé˜Ÿ</button>
        </div>
        <div class="btns">
          <button class="winbtn green"  id="btnA12">åŒä¸Š +3</button>
          <button class="winbtn orange" id="btnA13">ä¸€ä¸‰ +2</button>
          <button class="winbtn red"    id="btnA14">ä¸€å›› +1</button>
        </div>
      </div>
      <!-- Bé˜Ÿ -->
      <div class="row">
        <div class="card b" id="cardB">
          <div class="crown">ğŸ‘‘</div>
          <div class="left">
            <div class="level" id="lvB">2</div>
            <div class="suit">â™ </div>
          </div>
          <div class="meta">
            <span id="infoB">è·Aè¿˜å·® 12 çº§</span>
            <span class="fails" id="failB">A1å¤±è´¥ï¼š0/3</span>
          </div>
          <button type="button" class="badge team-name-btn" id="teamNameB" data-team="B">Bé˜Ÿ</button>
        </div>
        <div class="btns">
          <button class="winbtn green"  id="btnB12">åŒä¸Š +3</button>
          <button class="winbtn orange" id="btnB13">ä¸€ä¸‰ +2</button>
          <button class="winbtn red"    id="btnB14">ä¸€å›› +1</button>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨å·¥å…·æ¡ -->
    <div class="toolbar">
      <button class="undo" id="btnUndo" disabled>æ’¤å›ä¸Šä¸€æ­¥</button>
      <div class="status">
        <div id="dealerText">å½“å‰åº„å®¶ï¼šæš‚æ— </div>
      </div>
    </div>

    <!-- ç»ˆå±€æ¨ªå¹… -->
    <div class="winner" id="winner">
      <div class="sheet">
        <h2 id="winnerText">æŸé˜Ÿè·èƒœï¼</h2>
        <p>æœ¬å±€ç»“æŸï¼Œå¯åœ¨ä¸‹æ–¹â€œæ’¤å›ä¸Šä¸€æ­¥â€ä¿®æ­£è¯¯æ“ä½œã€‚</p>
        <button class="close" id="closeWinner">ç»§ç»­æŸ¥çœ‹</button>
      </div>
    </div>

    <!-- å†å²è®°å½•å¼¹å±‚ -->
    <div class="overlay" id="historyOverlay">
      <div class="panel">
        <header>
          <strong>å¯¹å±€å†å²</strong>
          <div>
            <button class="btn ghost" id="btnExport">å¯¼å‡ºJSON</button>
            <button class="btn" id="btnCloseHistory">å…³é—­</button>
          </div>
        </header>
        <ul class="history-list" id="historyList"></ul>
      </div>
    </div>

    <!-- é˜Ÿåç¼–è¾‘å¼¹å±‚ -->
    <div class="modal-overlay" id="renameOverlay">
      <div class="modal-card">
        <h3 id="renameTitle">è¯·è¾“å…¥é˜Ÿä¼çš„æ–°åç§°</h3>
        <input id="renameInput" type="text" maxlength="8" placeholder="ä¾‹å¦‚ï¼šå…ˆé”‹é˜Ÿ" />
        <div class="modal-actions">
          <button class="btn ghost" type="button" id="renameCancel">å–æ¶ˆ</button>
          <button class="btn primary" type="button" id="renameConfirm">ç¡®å®š</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===================== åŸºæœ¬å¸¸é‡ ===================== */
const LEVELS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const MAX_INDEX = 12; // 'A'
const APPLY_WINNER_DELTA_EVEN_IF_OPP_AT_A = true;

const TEAM_DEFAULTS = { A: 'Aé˜Ÿ', B: 'Bé˜Ÿ' };
let renameTarget = null;

function sanitizeTeamName(value, fallback = ''){
  if(typeof value !== 'string') return fallback;
  const trimmed = value.trim();
  if(!trimmed) return fallback;
  return trimmed.slice(0, 12);
}

function mergeTeams(teams){
  const merged = Object.assign({}, TEAM_DEFAULTS);
  if(teams && typeof teams === 'object'){
    if(Object.prototype.hasOwnProperty.call(teams, 'A')){
      merged.A = sanitizeTeamName(teams.A, merged.A);
    }
    if(Object.prototype.hasOwnProperty.call(teams, 'B')){
      merged.B = sanitizeTeamName(teams.B, merged.B);
    }
  }
  return merged;
}

const TEAM_ACTIONS = {
  A: [
    { id: 'btnA12', delta: 3, label: 'åŒä¸Š' },
    { id: 'btnA13', delta: 2, label: 'ä¸€ä¸‰' },
    { id: 'btnA14', delta: 1, label: 'ä¸€å››' }
  ],
  B: [
    { id: 'btnB12', delta: 3, label: 'åŒä¸Š' },
    { id: 'btnB13', delta: 2, label: 'ä¸€ä¸‰' },
    { id: 'btnB14', delta: 1, label: 'ä¸€å››' }
  ]
};

function getTeamName(code){
  const teams = (state && state.teams) ? state.teams : TEAM_DEFAULTS;
  if(!code) return '';
  const key = String(code).toUpperCase();
  return teams[key] || TEAM_DEFAULTS[key] || key;
}

function promptTeamName(team){
  if(!isReady) return;
  const overlay = el('renameOverlay');
  const input = el('renameInput');
  const title = el('renameTitle');
  if(!overlay || !input || !title) return;
  renameTarget = String(team).toUpperCase();
  const current = getTeamName(renameTarget);
  title.textContent = `è¯·è¾“å…¥${current}çš„æ–°åç§°`;
  input.value = current;
  overlay.style.display = 'flex';
  requestAnimationFrame(()=>{
    input.focus();
    input.select();
  });
}

function closeRenameModal(){
  const overlay = el('renameOverlay');
  const input = el('renameInput');
  if(overlay) overlay.style.display = 'none';
  if(input){
    input.blur();
    input.value = '';
  }
  renameTarget = null;
}

function submitRenameModal(){
  if(!renameTarget){
    closeRenameModal();
    return;
  }
  const input = el('renameInput');
  if(!input){
    closeRenameModal();
    return;
  }
  const current = getTeamName(renameTarget);
  const fallback = TEAM_DEFAULTS[renameTarget] || current;
  const normalized = sanitizeTeamName(input.value, fallback);
  if(normalized && normalized !== current){
    state.teams = mergeTeams(Object.assign({}, state.teams || {}, { [renameTarget]: normalized }));
    state.meta = state.meta || {};
    state.meta.updatedAt = new Date().toISOString();
    updateUI();
    persistState();
  }
  closeRenameModal();
}


 // è‹¥å¸Œæœ›åˆ°Aååªåˆ¤åº„å®¶ï¼Œä¸å†æ¶¨çº§ï¼Œæ”¹ä¸º false
function resolveApiBase(){
  if(window.GUANDAN_API_BASE){
    return window.GUANDAN_API_BASE;
  }
  const meta = document.querySelector('meta[name="guandan-api-base"]');
  if(meta && meta.content){
    return meta.content;
  }
  let origin = window.location.origin || '';
  if(origin === 'null'){
    origin = '';
  }
  let path = window.location.pathname || '/';
  if(!path){
    path = '/';
  }
  const parts = path.split('/');
  if(!(parts.length && parts[parts.length - 1] === '')){
    const lastSegment = parts.length ? parts[parts.length - 1] : '';
    if(lastSegment && lastSegment.indexOf('.') === -1){
      path = path + '/';
    }else{
      parts.pop();
      path = parts.join('/');
      if(path === ''){
        path = '/';
      }
    }
  }
  if(path.charAt(path.length - 1) !== '/'){
    path += '/';
  }
  return (origin ? origin : '') + path + 'games.php';
}

const API_BASE = resolveApiBase();
console.info('[guandan] API endpoint ->', API_BASE);

async function readJsonSafely(res){
  const text = await res.text();
  if(!text){
    return { json: null, text: '', parseError: null };
  }
  try{
    return { json: JSON.parse(text), text, parseError: null };
  }catch(parseError){
    return { json: null, text, parseError };
  }
}

function extractServerMessage(detail){
  if(!detail) return '';
  if(typeof detail === 'string'){
    return detail;
  }
  let message = '';
  if(detail.error_msg){
    message = detail.error_msg;
  }else if(detail.message){
    message = detail.message;
  }else if(detail.error){
    message = detail.error;
  }else if(detail.debug && detail.debug.description){
    message = detail.debug.description;
  }else if(detail.debug && detail.debug.message){
    message = detail.debug.message;
  }
  if(!message && detail.debug && detail.debug.number){
    message = 'é”™è¯¯ä»£ç  ' + detail.debug.number;
  }
  if(detail.debug && detail.debug.dataPath){
    const suffix = 'æ•°æ®æ–‡ä»¶: ' + detail.debug.dataPath;
    if(message){
      message += 'ï¼ˆ' + suffix + 'ï¼‰';
    }else{
      message = suffix;
    }
  }
  if(!message && detail.debug && detail.debug.dataPathSource){
    message = 'æ•°æ®æ¥æº: ' + detail.debug.dataPathSource;
  }
  return message || '';
}

function logApiFailure(context, res, payload){
  try{
    console.error('[api] ' + context + ' failed', {
      status: res ? res.status : null,
      statusText: res ? res.statusText : null,
      payload: payload ? (payload.json !== null ? payload.json : payload.text) : null,
      parseError: payload ? payload.parseError : null
    });
  }catch(logErr){
    console.error('[api] ' + context + ' failed', logErr);
  }
}

let currentGameId = null;
let isReady = false;
let statusClearTimer = null;

/* ===================== çŠ¶æ€åŠæŒä¹…åŒ– ===================== */
function freshState(){
  const now = new Date().toISOString();
  return {
    aLevel: 0, // index in LEVELS
    bLevel: 0,
    dealer: null, // 'A' | 'B' | null
    a1Fails: { A:0, B:0 }, // ä»…åœ¨â€œåº„å®¶åœ¨Aä¸”è¾“â€æ—¶ç´¯è®¡ï¼›åˆ°3å›2å¹¶æ¸…é›¶
    history: [],           // [{winner:'A'|'B', delta:1|2|3, pattern:'ä¸€å››'ç­‰, notes:[], ts:number}]
    gameOver: false,
    teams: mergeTeams(),
    meta: {
      id: null,
      createdAt: now,
      updatedAt: now
    }
  };
}

function hydrateState(remoteState, id){
  const base = freshState();
  const incoming = (remoteState && typeof remoteState === 'object') ? remoteState : {};
  const merged = Object.assign({}, base, incoming);
  merged.teams = mergeTeams(merged.teams);
  merged.a1Fails = Object.assign({}, base.a1Fails, incoming.a1Fails || {});
  merged.history = Array.isArray(incoming.history) ? incoming.history.map(item => ({...item})) : [];
  merged.meta = Object.assign({}, base.meta, incoming.meta || {});
  if(id) merged.meta.id = id;
  if(!merged.meta.createdAt) merged.meta.createdAt = base.meta.createdAt;
  if(!merged.meta.updatedAt) merged.meta.updatedAt = merged.meta.createdAt;
  return merged;
}

let state = freshState();
let autoRefreshTimer = null;
let isAutoSyncing = false;
let isSaving = false;

/* ===================== ç½‘ç»œä¸åŒæ­¥ ===================== */
async function apiFetchGame(id){
  const res = await fetch(`${API_BASE}?id=${encodeURIComponent(id)}`);
  const payload = await readJsonSafely(res);
  if(res.status === 404){
    const err = new Error('NOT_FOUND');
    err.code = 'NOT_FOUND';
    err.status = res.status;
    err.detail = payload.json !== null ? payload.json : payload.text;
    logApiFailure('fetchGame (404)', res, payload);
    throw err;
  }
  if(!res.ok){
    const err = new Error('FETCH_FAILED');
    err.status = res.status;
    err.detail = payload.json !== null ? payload.json : payload.text;
    err.code = (payload.json && payload.json.error) || 'FETCH_FAILED';
    logApiFailure('fetchGame', res, payload);
    throw err;
  }
  if(payload.parseError){
    const err = new Error('INVALID_JSON');
    err.code = 'INVALID_JSON';
    err.detail = payload.text;
    err.status = res.status;
    logApiFailure('fetchGame parse', res, payload);
    throw err;
  }
  return payload.json;
}

async function apiCreateGame(initialState){
  const res = await fetch(`${API_BASE}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ state: initialState })
  });
  const payload = await readJsonSafely(res);
  if(!res.ok){
    const err = new Error('CREATE_FAILED');
    err.status = res.status;
    err.detail = payload.json !== null ? payload.json : payload.text;
    err.code = (payload.json && (payload.json.error || payload.json.error_code)) || 'CREATE_FAILED';
    logApiFailure('createGame', res, payload);
    throw err;
  }
  if(payload.parseError){
    const err = new Error('INVALID_JSON');
    err.code = 'INVALID_JSON';
    err.detail = payload.text;
    err.status = res.status;
    logApiFailure('createGame parse', res, payload);
    throw err;
  }
  return payload.json;
}

async function apiUpdateGame(id, nextState){
  const res = await fetch(`${API_BASE}?id=${encodeURIComponent(id)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ state: nextState })
  });
  const payload = await readJsonSafely(res);
  if(!res.ok){
    const err = new Error('SAVE_FAILED');
    err.status = res.status;
    err.detail = payload.json !== null ? payload.json : payload.text;
    err.code = (payload.json && (payload.json.error || payload.json.error_code)) || 'SAVE_FAILED';
    logApiFailure('updateGame', res, payload);
    throw err;
  }
  if(payload.parseError){
    const err = new Error('INVALID_JSON');
    err.code = 'INVALID_JSON';
    err.detail = payload.text;
    err.status = res.status;
    logApiFailure('updateGame parse', res, payload);
    throw err;
  }
  return payload.json;
}

function updateUrlWithId(id){
  if(!id) return;
  const url = new URL(window.location.href);
  url.searchParams.set('id', id);
  window.history.replaceState(null, '', url);
}

function updateGameIdDisplay(){
  const display = document.getElementById('gameIdDisplay');
  if(display){
    if(currentGameId){
      display.textContent = currentGameId;
    }else if(!isReady){
      display.textContent = 'åŠ è½½ä¸­â€¦';
    }else{
      display.textContent = 'â€”';
    }
  }
  if(currentGameId){
    document.title = `æ¼è›‹è®°åˆ†å™¨ Â· #${currentGameId}`;
  }else if(isReady){
    document.title = 'æ¼è›‹è®°åˆ†å™¨ Â· æœªç¼–å·';
  }else{
    document.title = 'æ¼è›‹è®°åˆ†å™¨';
  }
}

function showStatus(message, tone='info'){
  const statusEl = document.getElementById('syncStatus');
  if(!statusEl) return;
  statusEl.textContent = message || '';
  if(tone){
    statusEl.setAttribute('data-tone', tone);
  }else{
    statusEl.removeAttribute('data-tone');
  }
  if(statusClearTimer){
    clearTimeout(statusClearTimer);
    statusClearTimer = null;
  }
  if(tone === 'ok'){
    statusClearTimer = setTimeout(()=>{
      if(statusEl.getAttribute('data-tone') === 'ok'){
        statusEl.textContent = '';
        statusEl.removeAttribute('data-tone');
      }
    }, 2000);
  }
}


async function persistState(){
  if(!isReady || !currentGameId) return;
  state.meta = Object.assign({}, state.meta || {}, {
    id: currentGameId,
    updatedAt: new Date().toISOString()
  });
  let saved = null;
  isSaving = true;
  const previousId = currentGameId;
  try{
    showStatus('æ­£åœ¨åŒæ­¥...', 'sync');
    saved = await apiUpdateGame(currentGameId, state);
    if(saved){
      if(saved.id){
        currentGameId = saved.id;
      }
      if(saved.state){
        state = hydrateState(saved.state, currentGameId);
      }
    }
    if(currentGameId !== previousId){
      updateUrlWithId(currentGameId);
      startAutoRefresh();
    } else {
      updateUrlWithId(currentGameId);
    }
    showStatus('å·²åŒæ­¥', 'ok');
    updateUI();
  }catch(err){
    console.error('åŒæ­¥å¤±è´¥', err);
    if(err && err.detail){
      console.error('server response detail', err.detail);
    }
    const extra = extractServerMessage(err && err.detail);
    const message = extra ? (`åŒæ­¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ï¼š${extra}`) : 'åŒæ­¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    showStatus(message, 'error');
  }finally{
    isSaving = false;
  }
}



async function refreshFromServer(options = {}){
  const forced = options && options.forced;
  if(!isReady || !currentGameId) return;
  if(isSaving && !forced) return;
  if(isAutoSyncing) return;
  isAutoSyncing = true;
  const localUpdated = state && state.meta ? state.meta.updatedAt : '';
  try{
    const remote = await apiFetchGame(currentGameId);
    if(!remote || !remote.state){
      return;
    }
    const remoteState = remote.state;
    const remoteUpdated = (remoteState.meta && remoteState.meta.updatedAt) ? remoteState.meta.updatedAt : '';
    if(!forced && localUpdated && remoteUpdated && remoteUpdated <= localUpdated){
      return;
    }
    state = hydrateState(remoteState, currentGameId);
    updateUI();
  }catch(err){
    console.warn('è‡ªåŠ¨åŒæ­¥å¤±è´¥', err);
  }finally{
    isAutoSyncing = false;
  }
}

function startAutoRefresh(){
  if(autoRefreshTimer){
    clearInterval(autoRefreshTimer);
  }
  autoRefreshTimer = setInterval(()=>{
    refreshFromServer();
  }, 2000);
  refreshFromServer({ forced: true });
}

function buildShareLink(){
  const url = new URL(window.location.href);
  if(currentGameId){
    url.searchParams.set('id', currentGameId);
  }
  return url.toString();
}

async function copyShareLink(){
  if(!currentGameId) return;
  const text = buildShareLink();
  try{
    await navigator.clipboard.writeText(text);
    showStatus('é“¾æ¥å·²å¤åˆ¶', 'ok');
  }catch(err){
    console.warn('Clipboard å¤åˆ¶å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æç¤ºæ¡†', err);
    window.prompt('æ‰‹åŠ¨å¤åˆ¶é“¾æ¥', text);
  }
}

async function createNewGameFromUI(){
  const confirmMsg = 'åˆ›å»ºæ–°ç‰Œå±€å°†ç”Ÿæˆæ–°çš„ç‰Œå±€IDï¼Œå½“å‰æ•°æ®ä¸ä¼šè‡ªåŠ¨ä¿ç•™ã€‚ç»§ç»­å—ï¼Ÿ';
  if(!window.confirm(confirmMsg)) return;
  const initial = freshState();
  try{
    showStatus('åˆ›å»ºæ–°ç‰Œå±€ä¸­â€¦', 'sync');
    const created = await apiCreateGame(initial);
    currentGameId = created.id;
    state = hydrateState(created.state || initial, currentGameId);
    updateUrlWithId(currentGameId);
    isReady = true;
    updateUI();
    showStatus('å·²åˆ›å»ºæ–°ç‰Œå±€', 'ok');
    startAutoRefresh();
  }catch(err){
    console.error('åˆ›å»ºç‰Œå±€å¤±è´¥', err);
    if(err && err.detail){
      console.error('server response detail', err.detail);
    }
    const extra = extractServerMessage(err && err.detail);
    const message = extra ? ('åˆ›å»ºç‰Œå±€å¤±è´¥: ' + extra) : 'åˆ›å»ºç‰Œå±€å¤±è´¥';
    showStatus(message, 'error');
  }
}

async function initialize(){
  const params = new URLSearchParams(window.location.search);
  const requestedId = params.get('id');
  let loaded = false;
  showStatus('åŠ è½½ä¸­â€¦', 'sync');
  try{
    if(requestedId){
      const remote = await apiFetchGame(requestedId);
      currentGameId = remote.id || requestedId;
      state = hydrateState(remote.state, currentGameId);
      updateUrlWithId(currentGameId);
      showStatus('ç‰Œå±€å·²åŠ è½½', 'ok');
    }else{
      const initial = freshState();
      const created = await apiCreateGame(initial);
      currentGameId = created.id;
      state = hydrateState(created.state || initial, currentGameId);
      updateUrlWithId(currentGameId);
      showStatus('å·²åˆ›å»ºæ–°ç‰Œå±€', 'ok');
    }
    loaded = true;
  }catch(err){
    if(err && err.code === 'NOT_FOUND'){
      try{
        const initial = freshState();
        const created = await apiCreateGame(initial);
        currentGameId = created.id;
        state = hydrateState(created.state || initial, currentGameId);
        updateUrlWithId(currentGameId);
        showStatus('å·²åˆ›å»ºæ–°ç‰Œå±€', 'warn');
        loaded = true;
      }catch(inner){
        console.error('è‡ªåŠ¨åˆ›å»ºæ–°ç‰Œå±€å¤±è´¥', inner);
        showStatus('æ— æ³•åˆ›å»ºæ–°ç‰Œå±€ï¼Œè¯·ç¨åå†è¯•', 'error');
      }
    }else{
      console.error('åŠ è½½ç‰Œå±€å¤±è´¥', err);
      showStatus('åŠ è½½å¤±è´¥ï¼Œè¯·ç¨ååˆ·æ–°', 'error');
    }
  }
  isReady = loaded;
  updateUI();
  startAutoRefresh();
}

/* ===================== å·¥å…·å‡½æ•° ===================== */
function el(id){ return document.getElementById(id); }
function teamLevel(team){ return team==='A' ? state.aLevel : state.bLevel; }
function setTeamLevel(team, idx){ if(team==='A') state.aLevel = idx; else state.bLevel = idx; }
function clampA(idx){ return Math.min(MAX_INDEX, Math.max(0, idx)); }
function isDealerAtA(){ return state.dealer && teamLevel(state.dealer) === MAX_INDEX; }

/* å°†ä¸€æ‰‹å¯¹å±€åº”ç”¨åˆ°å½“å‰çŠ¶æ€ï¼ˆæ ¸å¿ƒè§„åˆ™ï¼‰ */
function applyRoundCore(winner, delta, pattern, collectNotes=true){
  const entry = { winner, delta, pattern, notes: [], ts: Date.now() };
  const loser = (winner === 'A' ? 'B' : 'A');

  let skipWinnerDeltaThisRound = false; // æŸäº›æƒ…å½¢ï¼ˆç¬¬3æ¬¡Aä¸è¿‡å›2ï¼‰éœ€è¦è·³è¿‡æœ¬æ‰‹ç»™èµ¢å®¶åŠ çº§

  // â€”â€”A é˜¶æ®µç‰¹æ®Šåˆ¤å®šï¼šä»…å½“â€œåº„å®¶åœ¨Aâ€æ—¶ä»‹å…¥ï¼ˆä¿æŒä½ åŸæœ‰ç»“æ„ä¸å˜ï¼‰â€”â€”
  if (isDealerAtA()) {
    if (state.dealer === winner) {
      // åº„å®¶åœ¨Aä¸”èµ¢
      if (delta >= 2) {
        // ä¸€äºŒ / ä¸€ä¸‰ æ‰ç®—â€œè¿‡Aâ€ -> ç»ˆå±€ï¼ˆä¸ä½ åŸé€»è¾‘ä¸€è‡´ï¼Œä½†æ”¶ç´§æ¡ä»¶ï¼‰
        entry.notes.push('åº„å®¶åœ¨Aä¸”èµ¢ï¼ˆè¿‡Aï¼‰ï¼šæ•´å±€ç»“æŸ');
        state.gameOver = true;
        state.history.push(entry);
        state.dealer = winner; // è®°è´¦ä¸€è‡´
        return;
      } else {
        // delta===1 -> ä¸€å››ï¼šèµ¢ä½†æœªè¿‡Aï¼Œè®°Aä¸è¿‡ï¼ˆA1å¤±è´¥ï¼‰+1ï¼Œç»§ç»­æ‰“A
        state.a1Fails[state.dealer] = (state.a1Fails[state.dealer] || 0) + 1;
        entry.notes.push(`${state.dealer} åœ¨Aèµ¢â€œä¸€å››â€æœªè¿‡ï¼šA1å¤±è´¥ï¼ˆ${state.a1Fails[state.dealer]}/3ï¼‰`);
        if (state.a1Fails[state.dealer] >= 3) {
          // ç¬¬3æ¬¡ä½œä¸ºåº„å®¶æ‰“Aä¸è¿‡ -> å›åˆ°2ï¼Œå¹¶æ¸…é›¶è®¡æ•°
          setTeamLevel(state.dealer, 0);
          entry.notes.push(`${state.dealer} ç¬¬3æ¬¡A1å¤±è´¥ï¼šå›åˆ°2`);
          state.a1Fails[state.dealer] = 0;
          // è‹¥æœ¬æ‰‹èµ¢å®¶æ­£æ˜¯è¯¥åº„å®¶ï¼Œä¸ºä¿æŒâ€œå›åˆ°2â€çš„è½ç‚¹ï¼Œæœ¬æ‰‹ä¸å†ç»™å…¶åŠ çº§
          skipWinnerDeltaThisRound = true;
        }
      }
    } else {
      // åº„å®¶åœ¨Aä¸”è¾“ -> è®°Aä¸è¿‡ï¼ˆA1å¤±è´¥ï¼‰+1ï¼Œè¾¾åˆ°3æ¬¡å›åˆ°2ï¼ˆä¿æŒä½ åŸé€»è¾‘ï¼‰
      state.a1Fails[state.dealer] = (state.a1Fails[state.dealer] || 0) + 1;
      entry.notes.push(`${state.dealer} åœ¨Aå¤±åˆ©ï¼šA1å¤±è´¥ï¼ˆ${state.a1Fails[state.dealer]}/3ï¼‰`);
      if (state.a1Fails[state.dealer] >= 3) {
        setTeamLevel(state.dealer, 0);
        entry.notes.push(`${state.dealer} ç¬¬3æ¬¡A1å¤±è´¥ï¼šå›åˆ°2`);
        state.a1Fails[state.dealer] = 0;
      }
    }
  }

  // â€”â€”å¸¸è§„åŠ çº§ï¼šåªç»™èµ¢å®¶æ¶¨çº§ï¼ˆå°é¡¶Aï¼‰ã€‚æ˜¯å¦åœ¨Aé˜¶æ®µä»åŠ çº§ç”±ä½ åŸæ¥çš„å¼€å…³æ§åˆ¶â€”â€”
  const winnerAtA = (teamLevel(winner) === MAX_INDEX);
  const loserAtA  = (teamLevel(loser)  === MAX_INDEX);
  const shouldApply =
    APPLY_WINNER_DELTA_EVEN_IF_OPP_AT_A ? true : (!winnerAtA && !loserAtA);

  if (!skipWinnerDeltaThisRound && shouldApply) {
    const newIdx = clampA(teamLevel(winner) + delta);
    setTeamLevel(winner, newIdx);
  }

  // åº„å®¶æ›´æ–°ä¸ºæœ¬æ‰‹èµ¢å®¶ï¼ˆä¿æŒåŸè§„åˆ™ï¼šä¸Šä¸€æŠŠèµ¢çš„ååº„ï¼‰
  state.dealer = winner;

  // è®°å½•å†å²
  state.history.push(entry);
}

/* æ’¤å›ï¼šå›æ”¾å†å²é‡ç®— */
function recomputeFromHistory(){
  const snapshot = state.history.map(x => ({winner:x.winner, delta:x.delta, pattern:x.pattern}));
  const previousMeta = state.meta;
  const previousTeams = state.teams;
  state = freshState();
  state.teams = mergeTeams(previousTeams);
  state.meta = Object.assign({}, state.meta, previousMeta || {});
  state.meta.id = currentGameId;
  for(const h of snapshot){
    applyRoundCore(h.winner, h.delta, h.pattern);
    if(state.gameOver) break; // è‹¥æŸä¸€æ­¥å°±ç»ˆå±€ï¼Œåé¢æœ¬ä¸åº”å­˜åœ¨ï¼Œä½†ç¨³å¦¥å¤„ç†
  }
}

/* ===================== äº‹ä»¶å¤„ç† ===================== */
function record(winner, delta, pattern){
  if(!isReady || state.gameOver) return;
  applyRoundCore(winner, delta, pattern);
  state.meta.updatedAt = new Date().toISOString();
  updateUI();
  persistState();
}
function undo(){
  if(!isReady || state.history.length === 0) return;
  state.history.pop();
  recomputeFromHistory();
  state.meta.updatedAt = new Date().toISOString();
  updateUI();
  persistState();
}
function resetAll(){
  if(!isReady) return;
  if(!confirm('ç¡®å®šè¦é‡ç½®æœ¬å±€æ‰€æœ‰æ•°æ®å—ï¼Ÿï¼ˆäº‘ç«¯å­˜æ¡£ä¹Ÿä¼šæ¸…ç©ºï¼‰')) return;
  const previousMeta = state.meta;
  state = freshState();
  state.meta = Object.assign({}, state.meta, previousMeta || {});
  state.meta.id = currentGameId;
  state.meta.updatedAt = new Date().toISOString();
  updateUI();
  persistState();
}

/* ===================== UI æ¸²æŸ“ ===================== */

function updateUI() {
  updateGameIdDisplay();

  const nameA = getTeamName('A');
  const nameB = getTeamName('B');

  el('lvA').textContent = LEVELS[state.aLevel];
  el('lvB').textContent = LEVELS[state.bLevel];

  const remainingA = MAX_INDEX - state.aLevel;
  const remainingB = MAX_INDEX - state.bLevel;
  el('infoA').textContent = state.aLevel === MAX_INDEX ? `${nameA} å·²åˆ°é¡¶çº§` : `${nameA} è·é¡¶çº§è¿˜å·® ${remainingA} çº§`;
  el('infoB').textContent = state.bLevel === MAX_INDEX ? `${nameB} å·²åˆ°é¡¶çº§` : `${nameB} è·é¡¶çº§è¿˜å·® ${remainingB} çº§`;
  el('failA').textContent = `${nameA} A å¤±å®ˆï¼š${state.a1Fails.A || 0}/3`;
  el('failB').textContent = `${nameB} A å¤±å®ˆï¼š${state.a1Fails.B || 0}/3`;

  const teamBtnA = el('teamNameA');
  if (teamBtnA) {
    teamBtnA.textContent = nameA;
    teamBtnA.disabled = !isReady;
  }
  const teamBtnB = el('teamNameB');
  if (teamBtnB) {
    teamBtnB.textContent = nameB;
    teamBtnB.disabled = !isReady;
  }

  TEAM_ACTIONS.A.forEach(({ id, delta, label }) => {
    const btn = el(id);
    if (btn) {
      btn.textContent = `${label} +${delta}`;
    }
  });
  TEAM_ACTIONS.B.forEach(({ id, delta, label }) => {
    const btn = el(id);
    if (btn) {
      btn.textContent = `${label} +${delta}`;
    }
  });

  const disabled = (!isReady) || state.gameOver;
  ['btnA12','btnA13','btnA14','btnB12','btnB13','btnB14'].forEach(id => {
    const btn = el(id);
    if (btn) {
      btn.disabled = disabled;
    }
  });
  const undoButton = el('btnUndo');
  if (undoButton) {
    undoButton.disabled = (!isReady) || state.history.length === 0;
  }
  const allowActions = !!isReady;
  if (el('btnReset')) el('btnReset').disabled = !allowActions;
  if (el('btnHistory')) el('btnHistory').disabled = !allowActions;
  if (el('btnCopyLink')) el('btnCopyLink').disabled = (!allowActions) || !currentGameId;

  const dealerLabel = state.dealer ? getTeamName(state.dealer) : 'æœªç¡®å®š';
  el('dealerText').textContent = `å½“å‰åº„å®¶ï¼š${dealerLabel}`;
  el('cardA').classList.toggle('dealing', state.dealer === 'A');
  el('cardB').classList.toggle('dealing', state.dealer === 'B');

  const winnerLayer = el('winner');
  if (state.gameOver) {
    const text = state.dealer ? `${getTeamName(state.dealer)} è·èƒœ` : 'æœ¬å±€ç»“æŸ';
    el('winnerText').textContent = text;
    winnerLayer.style.display = 'flex';
  } else {
    winnerLayer.style.display = 'none';
  }

  const list = el('historyList');
  list.innerHTML = '';
  state.history.forEach((h, i) => {
    const li = document.createElement('li');
    li.className = 'history-item';
    const left = document.createElement('div');
    const winnerName = getTeamName(h.winner);
    left.innerHTML = `<strong>#${i + 1}</strong> <span class="tag">${winnerName} Â· ${h.pattern} +${h.delta}</span>`;
    const right = document.createElement('div');
    right.className = 'note';
    right.textContent = (h.notes && h.notes.length) ? h.notes.join('ã€') : '';
    li.appendChild(left);
    li.appendChild(right);
    list.appendChild(li);
  });
}



/* ===================== ç»‘å®šäº‹ä»¶ ===================== */
el('btnA12').addEventListener('click',()=>record('A',3,'åŒä¸Š'));
el('btnA13').addEventListener('click',()=>record('A',2,'ä¸€ä¸‰'));
el('btnA14').addEventListener('click',()=>record('A',1,'ä¸€å››'));

el('btnB12').addEventListener('click',()=>record('B',3,'åŒä¸Š'));
el('btnB13').addEventListener('click',()=>record('B',2,'ä¸€ä¸‰'));
el('btnB14').addEventListener('click',()=>record('B',1,'ä¸€å››'));

el('btnUndo').addEventListener('click', undo);
el('btnReset').addEventListener('click', resetAll);

const teamButtonA = el('teamNameA');
if(teamButtonA){ teamButtonA.addEventListener('click', ()=> promptTeamName('A')); }
const teamButtonB = el('teamNameB');
if(teamButtonB){ teamButtonB.addEventListener('click', ()=> promptTeamName('B')); }
const renameCancel = el('renameCancel');
if(renameCancel){ renameCancel.addEventListener('click', closeRenameModal); }
const renameConfirm = el('renameConfirm');
if(renameConfirm){ renameConfirm.addEventListener('click', submitRenameModal); }
const renameOverlay = el('renameOverlay');
if(renameOverlay){
  renameOverlay.addEventListener('click', (evt)=>{
    if(evt.target === renameOverlay){ closeRenameModal(); }
  });
}
const renameInput = el('renameInput');
if(renameInput){
  renameInput.addEventListener('keydown', (evt)=>{
    if(evt.key === 'Enter'){
      evt.preventDefault();
      submitRenameModal();
    } else if(evt.key === 'Escape'){
      evt.preventDefault();
      closeRenameModal();
    }
  });
}

el('btnCopyLink').addEventListener('click', ()=>{ if(!isReady || !currentGameId) return; copyShareLink(); });
el('btnNewGame').addEventListener('click', ()=>{ createNewGameFromUI(); });
el('btnHistory').addEventListener('click', ()=>{ if(!isReady) return; el('historyOverlay').style.display='flex'; });
el('btnCloseHistory').addEventListener('click', ()=>{ el('historyOverlay').style.display='none'; });
el('btnExport').addEventListener('click', ()=>{
  const data = JSON.stringify(state, null, 2);
  // ç®€æ˜“ä¸‹è½½
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `guandan-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
  a.click();
  URL.revokeObjectURL(url);
});

el('closeWinner').addEventListener('click', ()=>{ el('winner').style.display='none'; });

/* ===================== é¦–æ¬¡æ¸²æŸ“ ===================== */
updateUI();
initialize();
</script>
</body>
</html>



